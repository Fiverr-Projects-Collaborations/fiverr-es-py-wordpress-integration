//Create a map, where 1st number is the number of words in search bar,
//and 2nd number is the max score it can get.
Map m = new HashMap();
m.put(1, 28);
m.put(2, 88);
m.put(3, 164);
m.put(4, 272);
m.put(5, 420);
m.put(6, 616);
m.put(7, 868);
m.put(8, 1184);
m.put(9, 1572);
m.put(10, 2040);

//Score 1 logic

//initialize score 1
double score = 0;

//text that is search
String searchText = \"pizza mozzarella milano\".toLowerCase();

//combinations of searched text upto two tokens. EG: if 3 words searched, combinations of 3 words, combinations of 2 words
def arr_comb = [\"pizza mozzarella milano\",\"pizza mozzarella\",\"pizza milano\",\"mozzarella milano\"];

//create text by appending all the required fields by "," to be considered for sorting.
String text = ' ';
//if data exists in field, then append data else blank.
String pT = doc['post_title'].size()>0 ? doc['post_title.raw'].value : ' ';
String rT = doc['restaurant_title'].size()>0 ? doc['restaurant_title.raw'].value :' ';
String rM = doc['restaurant_name'].size()>0 ? doc['restaurant_name.raw'].value :' ';
String rA = doc['restaurant_address'].size()>0 ? doc['restaurant_address.raw'].value :' ';
String c = doc['city'].size()>0 ? doc['city.raw'].value :' ';
String fI = doc['food_ingredients'].size()>0 ? doc['food_ingredients.raw'].value :' ';
String fK = doc['food_keywords'].size()>0 ? doc['food_keywords.raw'].value :' ';
String fD = doc['food_description'].size()>0 ? doc['food_description.raw'].value :' ';
text = pT + ',' + rT + ',' + rM + ',' + rA + ',' + c + ',' + fI + ',' + fK + ',' + fD;
text = text.toLowerCase();

//create text by appending all the required fields by " ~ " to be considered for sorting.
//This is because when we try to split the text generted above with "," it would also split the food_ingredients that have comma,
//so doing this will also keep us in better place when we split text1 by " ~ ".
String text1 = pT + ' ~ ' + rT + ' ~ ' + rM + ' ~ ' + rA + ' ~ ' + c + ' ~ ' + fI + ' ~ ' + fK + ' ~ ' + fD;
text1=text1.toLowerCase();

//for each element y in arr_comb
for(String y: arr_comb){
  //if text contains element y
  if(text.contains(y.toLowerCase())){
    //add length of y/2 to the score
    score = score + \/ \/.split(y).length \/ 2;
  }
  //if searchText contains element y
  if(searchText.contains(y)) {
    //add length of y/2 to the score
    score = score + \/ \/.split(y).length \/ 2;
  }
}

//split "text" by ","
def new_l = Arrays.asList(\/,\/.split(text));
//for each element y in new_l
for(String y: new_l){
  //trim any white spaces eg: " barbeque sauce  " -> "barbeque sauce"
  String x = y.trim();
  //if arr_comb contains element x
  if (arr_comb.contains(x)){
    //add number of words in x to the score
    score = score + \/ \/.split(x).length;
  }
  //split searchText by spaces, split element x by spaces, if first array contains all from second array
  if(Arrays.asList(\/ \/.split(searchText)).containsAll(Arrays.asList(\/ \/.split(x))) ){
    //add number of words in x to the score
    score = score + \/ \/.split(x).length;
  }
  //split searchText by spaces, split element x by spaces, if first array contains any from second array
  if(!Collections.disjoint(Arrays.asList(\/ \/.split(searchText)), Arrays.asList(\/ \/.split(x)))){
    //add number of words in x to the score
    score = score + \/ \/.split(x).length;
  }
  //split x by spaces, split searchText by spaces, if first array contains all from second array
  if(Arrays.asList(\/ \/.split(x)).containsAll(Arrays.asList(\/ \/.split(searchText))) ){
    //add number of words in x to the score
    score = score + \/ \/.split(x).length;
  }
}

//searchText is exact match from any of the tokens in the list generated by splitting text by ","
//or searchText is exact match from any of the tokens in the list generated by splitting text1 by "~"
if(Arrays.asList(\/,\/.split(text)).contains(searchText) || Arrays.asList(\/ ~ \/.split(text1)).contains(searchText)) {
  //add length of search text * 1.5 to the score
  score = score + \/ \/.split(searchText).length * 1.5;
}

//score = score/maxScore * 33.33 -> the ratio gives value between 0-1,multiply by 33.33 for 1/3 of the total score
score = score\/m.get(\/ \/.split(searchText).length)*33.33;


//Score 2 logic
//Wilson score based on ratings and number of each rating. Logic as on the link shared.
long s1 = doc['r1'].value;
long s2 = doc['r2'].value;
long s3 = doc['r3'].value;
long s4 = doc['r4'].value;
long s5 = doc['r5'].value;
double p = (s1 * 0.0) + (s2 * 0.25) + (s3 * 0.5) + (s4 * 0.75) + (s5 * 1.0);
double n = (s1 * 1.0) + (s2 * 0.75) + (s3 * 0.5) + (s4 * 0.25) + (s5 * 0.0);
double wilsonScore = p + n > 0 ? ((p + 1.9208) \/ (p + n) - 1.96 * Math.sqrt((p * n) \/ (p + n) + 0.9604) \/ (p + n)) \/ (1 + 3.8416 \/ (p + n)) : 0;

//wilsonScore is between 0-1, multiply by 33.33 for 1/3 of the total score.
wilsonScore = wilsonScore * 33.33;

//Score 3 logic
//weight score based on considering max 10 weight.
//weight score/ 10 - gives value between 0-1 and multiply by 33.33 for 1/3 of the total score
double weight_score = doc['weight'].size()>0 ? doc['weight'].value\/10 * 33.33 : 0;

//adding all three scores.
double total_score = score + wilsonScore + weight_score;

//returing the final score for sorting.
return total_score;
